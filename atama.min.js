(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):(global=global||self,factory(global.atama={}))})(this,function(exports){"use strict";const listeners=[];const basicTypes=["boolean","number","null","undefined","string"];const getKey=stack=>stack.map(one=>one.property).join(".");const plain=value=>JSON.stringify(value);const handleChange=stack=>{listeners.forEach(one=>one(state,stack))};const getProxy=(stack=[])=>(target,property)=>{if(typeof property==="symbol"){return target[property]}const key=getKey([...stack,property]);return target[property]};const setProxy=(stack=[])=>(target,property,value)=>{const type=typeof target[property]==="undefined"?"create":"update";const previous=target[property];if(plain(previous)===plain(value)){return true}target[property]=value;const newStack=[...stack,{property:property,previous:previous,value:value}];const proxify=(value,stack)=>{if(basicTypes.includes(typeof value)||value===null){return value}if(Array.isArray(value)){value=value.map((value,property,target)=>{return proxify(value,newStack)})}if(/^\{/.test(JSON.stringify(value))){for(let property in value){const current={target:target,property:property,value:value[property]};value[property]=proxify(value[property],[...stack,current])}}return new Proxy(value,{get:getProxy(stack),set:setProxy(stack),deleteProperty:delProxy(stack)})};target[property]=proxify(value,newStack);handleChange(newStack);return true};const delProxy=(stack=[])=>(target,property)=>{delete target[property];handleChange(stack);return true};const state=new Proxy({},{get:getProxy(),set:setProxy(),deleteProperty:delProxy()});let useState=()=>{};let useEffect=()=>{};if(typeof require!=="undefined"){try{useState=require("react").useState;useEffect=require("react").useEffect}catch(error){}}const byType=args=>args.reduce((args,arg)=>({...args,[typeof arg]:arg}),{});const subscribe=(...args)=>{const{string:path,function:callback}=byType(args);const cb=(state,stack,previous)=>{const props=stack.map(({property:property})=>property).join(".");if(path){if(path.slice(0,props.length)!==props){return}}callback(state,stack)};listeners.push(cb);return()=>{const index=listeners.indexOf(cb);if(index===-1)return;listeners.splice(index,1)}};const useStore=(...args)=>{const[_,update]=useState({});useEffect(()=>subscribe(...args,data=>update(data)));return state};const connect=()=>console.error("This API is not available yet");const init=()=>console.error("This API is not available yet");const merge=(state,added={})=>freeze(state,temp=>{Object.assign(temp,added)});const freeze=async(state,cb)=>{const temp=engine.detach(state);await cb(temp);Object.assign(state,temp);engine.attach(temp)};var atama={state:state,subscribe:subscribe,connect:connect,init:init,merge:merge,freeze:freeze};exports.connect=connect;exports.default=atama;exports.freeze=freeze;exports.init=init;exports.merge=merge;exports.state=state;exports.subscribe=subscribe;exports.useStore=useStore;Object.defineProperty(exports,"__esModule",{value:true})});