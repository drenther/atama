(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):(global=global||self,factory(global.atama={}))})(this,function(exports){"use strict";const listeners=[];const basicTypes=["boolean","number","null","undefined","string"];const plain=value=>JSON.stringify(value);const handleChange=stack=>{listeners.forEach(one=>one(state,stack))};const getProxy=(stack=[])=>(target,property)=>{if(property===Symbol.iterator){const all=Object.values(target);return function*(){while(all.length)yield all.shift()}}if(typeof property==="symbol"){return target[property]}return target[property]};const setProxy=(stack=[])=>(target,property,value)=>{const previous=target[property];if(plain(previous)===plain(value)){return true}target[property]=value;const newStack=[...stack,{property:property,previous:previous,value:value}];const proxify=(value,stack)=>{if(basicTypes.includes(typeof value)||value===null){return value}if(Array.isArray(value)){value=value.map((value,property,target)=>{return proxify(value,newStack)})}if(/^\{/.test(JSON.stringify(value))){for(let property in value){const current={target:target,property:property,value:value[property]};value[property]=proxify(value[property],[...stack,current])}}return new Proxy(value,{get:getProxy(stack),set:setProxy(stack),deleteProperty:delProxy(stack)})};target[property]=proxify(value,newStack);handleChange(newStack);return true};const delProxy=(stack=[])=>(target,property)=>{if(Array.isArray(target)){target.splice(property,1)}else{delete target[property]}handleChange(stack);return true};const state=new Proxy({},{get:getProxy(),set:setProxy(),deleteProperty:delProxy()});let useState=()=>{};let useEffect=()=>{};if(typeof require!=="undefined"){try{useState=require("react").useState;useEffect=require("react").useEffect}catch(error){}}const byType=args=>args.reduce((args,arg)=>({...args,[typeof arg]:arg}),{});const find=(state,path)=>{if(!path)return state;return path.split(".").reduce((state,part)=>state[part],state)};const subscribe=(...args)=>{const{string:path,function:callback}=byType(args);let previous=JSON.stringify(find(state,path));const cb=(state,stack)=>{const current=JSON.stringify(find(state,path));if(previous===current)return;previous=current;return callback(find(state,path),stack)};listeners.push(cb);return()=>{const index=listeners.indexOf(cb);if(index===-1)return;listeners.splice(index,1)}};const useStore=(...args)=>{const{string:path,function:callback}=byType(args);const[_,update]=useState({});useEffect(()=>subscribe(...args,data=>update(data)));return find(state,path)};const connect=()=>console.error("This API is not available yet");var atama={state:state,subscribe:subscribe,useStore:useStore,connect:connect};exports.connect=connect;exports.default=atama;exports.state=state;exports.subscribe=subscribe;exports.useStore=useStore;Object.defineProperty(exports,"__esModule",{value:true})});